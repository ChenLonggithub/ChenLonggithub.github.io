<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="记录每一瞬间">


    <meta name="keywords" content="Java、博客、学习、感悟、程序员">


<title>RabbitMq 入门程序、整合SpringBoot | 水</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Clong&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Clong&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">RabbitMq 入门程序、整合SpringBoot</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">clong</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">五月 3, 2019&nbsp;&nbsp;22:20:06</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>​    MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced MessageQueue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。RabbitMQ官方地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p>
<p>​     RabbitMQ是一个由erlang语言编写的、开源的、在AMQP基础上完整的、可复用的企业消息系统。支持多种语言，包括java、Python、ruby、PHP、C/C++等。</p>
<p>​        AMQP：advanced message queuing protocol ，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息并不受客户端/中间件不同产品、不同开发语言等条件的限制。</p>
<h3 id="开发中消息队列通常有如下应用场景："><a href="#开发中消息队列通常有如下应用场景：" class="headerlink" title="开发中消息队列通常有如下应用场景："></a>开发中消息队列通常有如下应用场景：</h3><h4 id="1、任务异步处理。"><a href="#1、任务异步处理。" class="headerlink" title="1、任务异步处理。"></a>1、任务异步处理。</h4><p>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
<h4 id="2、应用程序解耦合"><a href="#2、应用程序解耦合" class="headerlink" title="2、应用程序解耦合"></a>2、应用程序解耦合</h4><p>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p>
<h4 id="市场上还有哪些消息队列？"><a href="#市场上还有哪些消息队列？" class="headerlink" title="市场上还有哪些消息队列？"></a>市场上还有哪些消息队列？</h4><p>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。</p>
<h4 id="为什么使用RabbitMQ呢？"><a href="#为什么使用RabbitMQ呢？" class="headerlink" title="为什么使用RabbitMQ呢？"></a>为什么使用RabbitMQ呢？</h4><p>1、使得简单，功能强大。<br>2、基于AMQP协议。<br>3、社区活跃，文档完善。<br>4、高并发性能好，这主要得益于Erlang语言。<br>5、Spring Boot默认已集成RabbitMQ </p>
<h3 id="二、RabbitMQ的工作原理"><a href="#二、RabbitMQ的工作原理" class="headerlink" title="二、RabbitMQ的工作原理"></a>二、RabbitMQ的工作原理</h3><p>基本结构图：</p>
<p><img src="http://img.cloong.top/FjkqplQI6CN6lueLiPxS84Y9xkSa" alt></p>
<p><strong>组成部分说明如下：</strong></p>
<ol>
<li>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。</li>
<li>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。</li>
<li>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。</li>
<li>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。</li>
<li>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。</li>
</ol>
<p><strong>消息发布接收流程：</strong><br>—–发送消息—–<br>  1、生产者和Broker建立TCP连接。<br>  2、生产者和Broker建立通道。<br>  3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。<br>  4、Exchange将消息转发到指定的Queue（队列）<br>—-接收消息—–<br>  1、消费者和Broker建立TCP连接<br>  2、消费者和Broker建立通道<br>  3、消费者监听指定的Queue（队列）<br>  4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>  5、消费者接收到消息。 </p>
<h3 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h3><p>​    RabbitMQ由Erlang语言开发，Erlang语言用于并发及分布式系统的开发，在电信领域应用广泛，OTP（OpenTelecom Platform）作为Erlang语言的一部分，包含了很多基于Erlang开发的中间件及工具库，安装RabbitMQ需要安装Erlang/OTP，并保持版本匹配：</p>
<p>安装注意：都要以管理员方式运行</p>
<p>1、RabbitMQ的下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a> </p>
<p>2、下载erlang，地址如下：<a href="http://erlang.org/download/otp_win64_20.3.exe" target="_blank" rel="noopener">http://erlang.org/download/otp_win64_20.3.exe</a> （erlang安装完成需要配置erlang环境变量： ERLANG_HOME=D:\Program Files\erl9.3 在path中添加%ERLANG_HOME%\bin; ）</p>
<h4 id="启动注意："><a href="#启动注意：" class="headerlink" title="启动注意："></a>启动注意：</h4><p>安装成功后会自动创建RabbitMQ服务并且启动。</p>
<p><strong>1、从开始菜单启动RabbitMQ</strong></p>
<p>完成后在开始菜单找到RabbitMQ的菜单：安装成功后会自动创建RabbitMQ服务并且启动，从开始菜单启动RabbitMQ</p>
<p>​     RabbitMQ Service-install :安装服务</p>
<p>​     RabbitMQ Service-remove 删除服务</p>
<p>​     RabbitMQ Service-start 启动</p>
<p>​     RabbitMQ Service-stop 启动</p>
<p>2、如果没有开始菜单则进入安装目录下sbin目录手动启动：</p>
<p>1）安装并运行服务：</p>
<p>​    rabbitmq-service.bat install 安装服务 </p>
<p>​    rabbitmq-service.bat stop 停止服务 </p>
<p>​    rabbitmq-service.bat start 启动服务</p>
<p>2）安装管理插件，安装rabbitMQ的管理插件，可以在浏览器端管理RabbitMQ</p>
<p>​    管理员身份运行（进入sbin目录） ：rabbitmq-plugins.bat enable rabbitmq_management</p>
<p>3、启动成功 登录RabbitMQ，进入浏览器，输入：<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a> (guest/guest)</p>
<p><img src="http://img.cloong.top/FqwiGargYDjJAKaSv7ytUjG7MxYy" alt></p>
<p><img src="http://img.cloong.top/FmlHUWZX8LEk6tDmBiVEUOl9QU1u" alt></p>
<h3 id="四、Hello-RabbitMq"><a href="#四、Hello-RabbitMq" class="headerlink" title="四、Hello RabbitMq"></a>四、Hello RabbitMq</h3><p>Rabbit有一个生产者和一个消费者，生产者发送需要被处理的信息，消费端则是负责解决问题</p>
<h5 id="1、创建maven工程："><a href="#1、创建maven工程：" class="headerlink" title="1、创建maven工程："></a>1、创建maven工程：</h5><p>​                test-producer 生产者</p>
<p>​                test-consumer 消费者</p>
<h5 id="2、加入依赖："><a href="#2、加入依赖：" class="headerlink" title="2、加入依赖："></a>2、加入依赖：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp‐client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;<span class="name">!‐‐此版本与spring</span> <span class="attr">boot</span> <span class="attr">1.5.9</span>版本匹配‐‐&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3、生产者代码："><a href="#3、生产者代码：" class="headerlink" title="3、生产者代码："></a>3、生产者代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*设置一个队列的名称*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"START_HELLO"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过连接工厂创建新的连接和mq建立连接</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//端口</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立新连接</span></span><br><span class="line">            connection = connectionFactory.newConnection();</span><br><span class="line">            <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//声明队列，如果队列在mq 中没有则要创建</span></span><br><span class="line">            <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数明细</span></span><br><span class="line"><span class="comment">             * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">             * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            <span class="comment">//参数：String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数明细：</span></span><br><span class="line"><span class="comment">             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为""）</span></span><br><span class="line"><span class="comment">             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</span></span><br><span class="line"><span class="comment">             * 3、props，消息的属性</span></span><br><span class="line"><span class="comment">             * 4、body，消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//消息内容</span></span><br><span class="line">            String message = <span class="string">"Hello - rabbit"</span>+ System.currentTimeMillis();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"send   message ======&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span> + message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭通道</span></span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行代码：可以看到rabbit里面有了消息待处理：</p>
<p><img src="http://img.cloong.top/FqB7jHHYetWyf1xpV9BBJyNMpMkI" alt></p>
<h5 id="4、消费者代码："><a href="#4、消费者代码：" class="headerlink" title="4、消费者代码："></a>4、消费者代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*设置一个队列的名称*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"START_HELLO"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//通过连接工厂创建新的连接和mq建立连接</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//端口</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立新连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//声明队列，如果队列在mq 中没有则要创建</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当接收到消息后此方法将被调用</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope    信封，通过envelope</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties  消息属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body        消息内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                String exchange = envelope.getExchange();</span><br><span class="line">                <span class="comment">//消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">//消息内容</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"receive message:"</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean autoAck, Consumer callback</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</span></span><br><span class="line"><span class="comment">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE, <span class="keyword">true</span>, defaultConsumer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，看到消息已经处理了</p>
<p><img src="http://img.cloong.top/FhFE3_KHYyL7smCNIlZYYxDixWuT" alt></p>
<h5 id="步骤总结："><a href="#步骤总结：" class="headerlink" title="步骤总结："></a>步骤总结：</h5><p><strong>1、发送端操作流程</strong><br>    1）创建连接<br>    2）创建通道<br>    3）声明队列<br>    4）发送消息<br><strong>2、接收端操作流程</strong><br>    1）创建连接<br>    2）创建通道<br>    3）声明队列<br>    4）监听队列<br>    5）接收消息 </p>
<h3 id="五：RabbitMQ五种消息发送模式"><a href="#五：RabbitMQ五种消息发送模式" class="headerlink" title="五：RabbitMQ五种消息发送模式"></a>五：RabbitMQ五种消息发送模式</h3><p> RabbitMQ包括六种队列模式，简单队列、Work queues、Publish/Subscribe、router、topics、header，rpc。</p>
<h4 id="0、普通"><a href="#0、普通" class="headerlink" title="0、普通"></a>0、普通</h4><p><img src="http://img.cloong.top/FpxExivrLuZQQ7Q4Ydf9vwDDNCVL" alt></p>
<p>​    1、生产者将消息发送到队列，消费者从队列获取消息。</p>
<p>​        2、一个队列对应一个消费者。</p>
<p>hello rabbit 已经测试</p>
<h4 id="1、Work-Queues"><a href="#1、Work-Queues" class="headerlink" title="1、Work Queues"></a>1、Work Queues</h4><p><img src="http://img.cloong.top/FvLwRDnIp20d6uEaDbYqNSSg7xid" alt></p>
<p>work queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息。应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</p>
<p><strong>测试：</strong><br>    1）、使用入门程序，启动多个消费者。<br>    2）、生产者发送多个消息。</p>
<p><strong>结果：</strong><br>    1）、一条消息只会被一个消费者接收；<br>    2）、rabbit采用轮询的方式将消息是平均发送给消费者的；<br>    3）、消费者在处理完某条消息后，才会收到下一条消息。 </p>
<p>  注意:channel.basicQos(1)表示同一时刻只发送一条消息给消费者。</p>
<h4 id="2、Publish-Subscribe"><a href="#2、Publish-Subscribe" class="headerlink" title="2、Publish/Subscribe"></a>2、Publish/Subscribe</h4><p><img src="http://img.cloong.top/FsTTozgPgI3Dnzwz6kiRjYS_o2tu" alt></p>
<p>​    </p>
<p> 1、一个生产者，多个消费者。</p>
<p> 2、每一个消费者都有自己的一个队列。</p>
<p>3、生产者没有将消息直接发送到队列，而是发送到交换机。</p>
<p> 4、每一个队列都要绑定到交换机。</p>
<p>5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的。</p>
<p>6、交换机类型为“fanout”。</p>
<p> 注意：交换机本身没有存储消息的能力，消息只能存储到队列中。</p>
<h4 id="3、Router"><a href="#3、Router" class="headerlink" title="3、Router"></a>3、Router</h4><p><img src="http://img.cloong.top/FuQSUAFSzMPYen39156iLodMIpyf" alt></p>
<p>路由模式是发布/订阅模式的一种特殊情况。</p>
<p>​        1、路由模式的交换机类型为“direct”。</p>
<p>​        2、绑定队列到交换机时指定 key，即路由键，一个队列可以指定多个路由键。</p>
<p>​        3、生产者发送消息时指定路由键，这时，消息只会发送到绑定的key的对应队列中。</p>
<h4 id="4、Topics"><a href="#4、Topics" class="headerlink" title="4、Topics"></a>4、Topics</h4><p><img src="http://img.cloong.top/FuQSUAFSzMPYen39156iLodMIpyf" alt></p>
<ol>
<li>将路由键和某模式进行匹配。此时，队列需要绑定到一个模式上。</li>
<li>符号“#”匹配一个或多个词，“*”匹配不多不少一个词。</li>
<li>绑定队列到交换机指定key时，进行通配符模式匹配。</li>
</ol>
<h4 id="5、Header"><a href="#5、Header" class="headerlink" title="5、Header"></a>5、Header</h4><p>​    header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。</p>
<h4 id="6、Rpc"><a href="#6、Rpc" class="headerlink" title="6、Rpc"></a>6、Rpc</h4><p><img src="http://img.cloong.top/FnQA1dHvJhKzNJiappKWQ6QMRi4m" alt></p>
<p>RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下：<br>1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。<br>2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果<br>3、服务端将RPC方法 的结果发送到RPC响应队列<br>4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。 </p>
<h3 id="六、RabbitMQ的其他特性"><a href="#六、RabbitMQ的其他特性" class="headerlink" title="六、RabbitMQ的其他特性"></a>六、RabbitMQ的其他特性</h3><h4 id="1、消息确认机制"><a href="#1、消息确认机制" class="headerlink" title="1、消息确认机制"></a>1、消息确认机制</h4><p>​        生产者发送消息到RabbitMQ服务器，消费者从RabbitMQ服务器获取消息，服务端如何知道消息被消费者正常消费了呢？这就要说消息确认机制，RabbitMQ有两种消息确认机制。</p>
<p>​        模式1：自动确认</p>
<p>​        只要消息从队列中获取，无论消费者获取到消息后是否成功消费消息，服务端都认为消息成功被消费。</p>
<p>​        模式2：手动确认</p>
<p>​        消费者从队列获取消息后，服务器会将消息标记为不可用状态，等待消费者的反馈。如果消费者一直没有反馈，那么该消息将一直处于不可用状态。api:channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</p>
<h4 id="2、持久化交换机和队列"><a href="#2、持久化交换机和队列" class="headerlink" title="2、持久化交换机和队列"></a>2、持久化交换机和队列</h4><p>​        持久化：将交换机或队列数据保存到磁盘，服务器宕机或者重启之后数据依然存在。</p>
<p>​        非持久化：将交换机或队列数据保存到磁盘到内存，服务器宕机或者重启之后数据会丢失。</p>
<p>​        持久化性能要低于持久化，是否开启持久化取决于业务需求。</p>
<h3 id="七：整合springboot"><a href="#七：整合springboot" class="headerlink" title="七：整合springboot"></a>七：整合springboot</h3><h4 id="1、创建两个maven工程"><a href="#1、创建两个maven工程" class="headerlink" title="1、创建两个maven工程"></a>1、创建两个maven工程</h4><p>​        test-springboot-producer</p>
<p>​        test-springboot-consumer</p>
<h4 id="2、加入依赖"><a href="#2、加入依赖" class="headerlink" title="2、加入依赖"></a>2、加入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rabbitmq依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">    publisher-confirms:</span> <span class="literal">true</span>    <span class="comment">#  消息发送到交换机确认机制,是否确认回调</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h4 id="4，配置代码（两个工程到放到config）"><a href="#4，配置代码（两个工程到放到config）" class="headerlink" title="4，配置代码（两个工程到放到config）"></a>4，配置代码（两个工程到放到config）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_INFORM_EMAIL = <span class="string">"queue_inform_email"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_INFORM_SMS = <span class="string">"queue_inform_sms"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_TOPICS_INFORM = <span class="string">"exchange_topics_inform"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机配置</span></span><br><span class="line"><span class="comment">     * ExchangeBuilder提供了fanout、direct、topic、header交换机类型的配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the exchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(EXCHANGE_TOPICS_INFORM)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exchange <span class="title">EXCHANGE_TOPICS_INFORM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//durable(true)持久化，消息队列重启后交换机仍然存在</span></span><br><span class="line">        <span class="keyword">return</span> (Exchange) ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(<span class="keyword">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(QUEUE_INFORM_SMS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">QUEUE_INFORM_SMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(QUEUE_INFORM_SMS);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(QUEUE_INFORM_EMAIL)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">QUEUE_INFORM_EMAIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue(QUEUE_INFORM_EMAIL);</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * channel.queueBind(INFORM_QUEUE_SMS,"inform_exchange_topic","inform.#.sms.#");</span></span><br><span class="line"><span class="comment">     * 绑定队列到交换机 .</span></span><br><span class="line"><span class="comment">     * *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue    the queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange the exchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the binding</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">BINDING_QUEUE_INFORM_SMS</span><span class="params">(@Qualifier(QUEUE_INFORM_SMS)</span> Queue queue,</span></span><br><span class="line"><span class="function">                                            @<span class="title">Qualifier</span><span class="params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"inform.#.sms.#"</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">BINDING_QUEUE_INFORM_EMAIL</span><span class="params">(@Qualifier(QUEUE_INFORM_EMAIL)</span> Queue queue,</span></span><br><span class="line"><span class="function">                                              @<span class="title">Qualifier</span><span class="params">(EXCHANGE_TOPICS_INFORM)</span> Exchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"inform.#.email.#"</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、生产者代码"><a href="#5、生产者代码" class="headerlink" title="5、生产者代码"></a>5、生产者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendByTopics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        String message = <span class="string">"sms email inform to user"</span> + i;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitConfig.EXCHANGE_TOPICS_INFORM, <span class="string">"inform.sms.email"</span>, message);</span><br><span class="line">        System.out.println(<span class="string">"Send Message is:'"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、消费者代码"><a href="#6、消费者代码" class="headerlink" title="6、消费者代码"></a>6、消费者代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = &#123;RabbitConfig.QUEUE_INFORM_EMAIL&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive_email</span><span class="params">(String msg, Message message, AMQP.Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"QUEUE_INFORM_EMAIL"</span>+<span class="string">"===============&gt;&gt;&gt;&gt;&gt;"</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = &#123;RabbitConfig.QUEUE_INFORM_SMS&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive_sms</span><span class="params">(String msg, Message message, AMQP.Channel channel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"QUEUE_INFORM_SMS==============&gt;&gt;&gt;&gt;"</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试完成了，更多功能待开发…….</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>clong</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://coldwater.com/2019/05/04/RabbitMq-入门程序、整合SpringBoot/">http://coldwater.com/2019/05/04/RabbitMq-入门程序、整合SpringBoot/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/RabbitMq/"># RabbitMq</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/06/04/操作系统/">操作系统</a>
            
            
            <a class="next" rel="next" href="/2019/04/29/如何自定义点击按钮上传图片和文件的上传、下载/">如何自定义点击按钮上传图片和文件的上传、下载</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Clong | Jgsu </span>
    </div>
</footer>

    </div>
</body>
</html>
